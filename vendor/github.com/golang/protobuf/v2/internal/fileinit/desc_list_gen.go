// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style.
// license that can be found in the LICENSE file.

// Code generated by generate-types. DO NOT EDIT.

package fileinit

import (
	"fmt"
	"sync"

	"github.com/golang/protobuf/v2/internal/pragma"
	"github.com/golang/protobuf/v2/internal/typefmt"
	"github.com/golang/protobuf/v2/reflect/protoreflect"
)

type enumDescs struct {
	list   []enumDesc
	once   sync.Once
	byName map[protoreflect.Name]*enumDesc // protected by once
}

func (p *enumDescs) Len() int {
	return len(p.list)
}
func (p *enumDescs) Get(i int) protoreflect.EnumDescriptor {
	return &p.list[i]
}
func (p *enumDescs) ByName(s protoreflect.Name) protoreflect.EnumDescriptor {
	if d := p.lazyInit().byName[s]; d != nil {
		return d
	}
	return nil
}
func (p *enumDescs) Format(s fmt.State, r rune) {
	typefmt.FormatList(s, r, p)
}
func (p *enumDescs) ProtoInternal(pragma.DoNotImplement) {}
func (p *enumDescs) lazyInit() *enumDescs {
	p.once.Do(func() {
		if len(p.list) > 0 {
			p.byName = make(map[protoreflect.Name]*enumDesc, len(p.list))
			for i := range p.list {
				d := &p.list[i]
				if _, ok := p.byName[d.Name()]; !ok {
					p.byName[d.Name()] = d
				}
			}
		}
	})
	return p
}

type enumValueDescs struct {
	list   []enumValueDesc
	once   sync.Once
	byName map[protoreflect.Name]*enumValueDesc       // protected by once
	byNum  map[protoreflect.EnumNumber]*enumValueDesc // protected by once
}

func (p *enumValueDescs) Len() int {
	return len(p.list)
}
func (p *enumValueDescs) Get(i int) protoreflect.EnumValueDescriptor {
	return &p.list[i]
}
func (p *enumValueDescs) ByName(s protoreflect.Name) protoreflect.EnumValueDescriptor {
	if d := p.lazyInit().byName[s]; d != nil {
		return d
	}
	return nil
}
func (p *enumValueDescs) ByNumber(n protoreflect.EnumNumber) protoreflect.EnumValueDescriptor {
	if d := p.lazyInit().byNum[n]; d != nil {
		return d
	}
	return nil
}
func (p *enumValueDescs) Format(s fmt.State, r rune) {
	typefmt.FormatList(s, r, p)
}
func (p *enumValueDescs) ProtoInternal(pragma.DoNotImplement) {}
func (p *enumValueDescs) lazyInit() *enumValueDescs {
	p.once.Do(func() {
		if len(p.list) > 0 {
			p.byName = make(map[protoreflect.Name]*enumValueDesc, len(p.list))
			p.byNum = make(map[protoreflect.EnumNumber]*enumValueDesc, len(p.list))
			for i := range p.list {
				d := &p.list[i]
				if _, ok := p.byName[d.Name()]; !ok {
					p.byName[d.Name()] = d
				}
				if _, ok := p.byNum[d.Number()]; !ok {
					p.byNum[d.Number()] = d
				}
			}
		}
	})
	return p
}

type messageDescs struct {
	list   []messageDesc
	once   sync.Once
	byName map[protoreflect.Name]*messageDesc // protected by once
}

func (p *messageDescs) Len() int {
	return len(p.list)
}
func (p *messageDescs) Get(i int) protoreflect.MessageDescriptor {
	return &p.list[i]
}
func (p *messageDescs) ByName(s protoreflect.Name) protoreflect.MessageDescriptor {
	if d := p.lazyInit().byName[s]; d != nil {
		return d
	}
	return nil
}
func (p *messageDescs) Format(s fmt.State, r rune) {
	typefmt.FormatList(s, r, p)
}
func (p *messageDescs) ProtoInternal(pragma.DoNotImplement) {}
func (p *messageDescs) lazyInit() *messageDescs {
	p.once.Do(func() {
		if len(p.list) > 0 {
			p.byName = make(map[protoreflect.Name]*messageDesc, len(p.list))
			for i := range p.list {
				d := &p.list[i]
				if _, ok := p.byName[d.Name()]; !ok {
					p.byName[d.Name()] = d
				}
			}
		}
	})
	return p
}

type fieldDescs struct {
	list   []fieldDesc
	once   sync.Once
	byName map[protoreflect.Name]*fieldDesc        // protected by once
	byJSON map[string]*fieldDesc                   // protected by once
	byNum  map[protoreflect.FieldNumber]*fieldDesc // protected by once
}

func (p *fieldDescs) Len() int {
	return len(p.list)
}
func (p *fieldDescs) Get(i int) protoreflect.FieldDescriptor {
	return &p.list[i]
}
func (p *fieldDescs) ByName(s protoreflect.Name) protoreflect.FieldDescriptor {
	if d := p.lazyInit().byName[s]; d != nil {
		return d
	}
	return nil
}
func (p *fieldDescs) ByJSONName(s string) protoreflect.FieldDescriptor {
	if d := p.lazyInit().byJSON[s]; d != nil {
		return d
	}
	return nil
}
func (p *fieldDescs) ByNumber(n protoreflect.FieldNumber) protoreflect.FieldDescriptor {
	if d := p.lazyInit().byNum[n]; d != nil {
		return d
	}
	return nil
}
func (p *fieldDescs) Format(s fmt.State, r rune) {
	typefmt.FormatList(s, r, p)
}
func (p *fieldDescs) ProtoInternal(pragma.DoNotImplement) {}
func (p *fieldDescs) lazyInit() *fieldDescs {
	p.once.Do(func() {
		if len(p.list) > 0 {
			p.byName = make(map[protoreflect.Name]*fieldDesc, len(p.list))
			p.byJSON = make(map[string]*fieldDesc, len(p.list))
			p.byNum = make(map[protoreflect.FieldNumber]*fieldDesc, len(p.list))
			for i := range p.list {
				d := &p.list[i]
				if _, ok := p.byName[d.Name()]; !ok {
					p.byName[d.Name()] = d
				}
				if _, ok := p.byJSON[d.JSONName()]; !ok {
					p.byJSON[d.JSONName()] = d
				}
				if _, ok := p.byNum[d.Number()]; !ok {
					p.byNum[d.Number()] = d
				}
			}
		}
	})
	return p
}

type oneofDescs struct {
	list   []oneofDesc
	once   sync.Once
	byName map[protoreflect.Name]*oneofDesc // protected by once
}

func (p *oneofDescs) Len() int {
	return len(p.list)
}
func (p *oneofDescs) Get(i int) protoreflect.OneofDescriptor {
	return &p.list[i]
}
func (p *oneofDescs) ByName(s protoreflect.Name) protoreflect.OneofDescriptor {
	if d := p.lazyInit().byName[s]; d != nil {
		return d
	}
	return nil
}
func (p *oneofDescs) Format(s fmt.State, r rune) {
	typefmt.FormatList(s, r, p)
}
func (p *oneofDescs) ProtoInternal(pragma.DoNotImplement) {}
func (p *oneofDescs) lazyInit() *oneofDescs {
	p.once.Do(func() {
		if len(p.list) > 0 {
			p.byName = make(map[protoreflect.Name]*oneofDesc, len(p.list))
			for i := range p.list {
				d := &p.list[i]
				if _, ok := p.byName[d.Name()]; !ok {
					p.byName[d.Name()] = d
				}
			}
		}
	})
	return p
}

type extensionDescs struct {
	list   []extensionDesc
	once   sync.Once
	byName map[protoreflect.Name]*extensionDesc // protected by once
}

func (p *extensionDescs) Len() int {
	return len(p.list)
}
func (p *extensionDescs) Get(i int) protoreflect.ExtensionDescriptor {
	return &p.list[i]
}
func (p *extensionDescs) ByName(s protoreflect.Name) protoreflect.ExtensionDescriptor {
	if d := p.lazyInit().byName[s]; d != nil {
		return d
	}
	return nil
}
func (p *extensionDescs) Format(s fmt.State, r rune) {
	typefmt.FormatList(s, r, p)
}
func (p *extensionDescs) ProtoInternal(pragma.DoNotImplement) {}
func (p *extensionDescs) lazyInit() *extensionDescs {
	p.once.Do(func() {
		if len(p.list) > 0 {
			p.byName = make(map[protoreflect.Name]*extensionDesc, len(p.list))
			for i := range p.list {
				d := &p.list[i]
				if _, ok := p.byName[d.Name()]; !ok {
					p.byName[d.Name()] = d
				}
			}
		}
	})
	return p
}

type serviceDescs struct {
	list   []serviceDesc
	once   sync.Once
	byName map[protoreflect.Name]*serviceDesc // protected by once
}

func (p *serviceDescs) Len() int {
	return len(p.list)
}
func (p *serviceDescs) Get(i int) protoreflect.ServiceDescriptor {
	return &p.list[i]
}
func (p *serviceDescs) ByName(s protoreflect.Name) protoreflect.ServiceDescriptor {
	if d := p.lazyInit().byName[s]; d != nil {
		return d
	}
	return nil
}
func (p *serviceDescs) Format(s fmt.State, r rune) {
	typefmt.FormatList(s, r, p)
}
func (p *serviceDescs) ProtoInternal(pragma.DoNotImplement) {}
func (p *serviceDescs) lazyInit() *serviceDescs {
	p.once.Do(func() {
		if len(p.list) > 0 {
			p.byName = make(map[protoreflect.Name]*serviceDesc, len(p.list))
			for i := range p.list {
				d := &p.list[i]
				if _, ok := p.byName[d.Name()]; !ok {
					p.byName[d.Name()] = d
				}
			}
		}
	})
	return p
}

type methodDescs struct {
	list   []methodDesc
	once   sync.Once
	byName map[protoreflect.Name]*methodDesc // protected by once
}

func (p *methodDescs) Len() int {
	return len(p.list)
}
func (p *methodDescs) Get(i int) protoreflect.MethodDescriptor {
	return &p.list[i]
}
func (p *methodDescs) ByName(s protoreflect.Name) protoreflect.MethodDescriptor {
	if d := p.lazyInit().byName[s]; d != nil {
		return d
	}
	return nil
}
func (p *methodDescs) Format(s fmt.State, r rune) {
	typefmt.FormatList(s, r, p)
}
func (p *methodDescs) ProtoInternal(pragma.DoNotImplement) {}
func (p *methodDescs) lazyInit() *methodDescs {
	p.once.Do(func() {
		if len(p.list) > 0 {
			p.byName = make(map[protoreflect.Name]*methodDesc, len(p.list))
			for i := range p.list {
				d := &p.list[i]
				if _, ok := p.byName[d.Name()]; !ok {
					p.byName[d.Name()] = d
				}
			}
		}
	})
	return p
}
